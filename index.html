<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mermaid Visual Editor</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mermaid/10.6.1/mermaid.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        :root {
            /* Dark theme (default) */
            --bg-primary: #1a1a1a;
            --bg-secondary: #252526;
            --bg-tertiary: #1e1e1e;
            --bg-hover: #3c3c3c;
            --bg-active: #505050;
            --border-color: #3e3e42;
            --border-hover: #464647;
            --text-primary: #fff;
            --text-secondary: #cccccc;
            --text-tertiary: #999;
            --accent-primary: #007acc;
            --accent-hover: #40a9ff;
            --grid-color: rgba(255,255,255,0.1);
            --node-shadow: rgba(0,0,0,0.3);
            --connection-color: #999;
            --code-bg: #1e1e1e;
            --code-text: #d4d4d4;
            --canvas-bg: #1e1e1e;
        }
        
        body.light-mode {
            /* Light theme */
            --bg-primary: #f5f5f5;
            --bg-secondary: #fafafa;
            --bg-tertiary: #fafafa;
            --bg-hover: #f0f0f0;
            --bg-active: #e0e0e0;
            --border-color: #e0e0e0;
            --border-hover: #d0d0d0;
            --text-primary: #1a1a1a;
            --text-secondary: #333333;
            --text-tertiary: #666666;
            --accent-primary: #0066cc;
            --accent-hover: #0052cc;
            --grid-color: rgba(0,0,0,0.05);
            --node-shadow: rgba(0,0,0,0.1);
            --connection-color: #666;
            --code-bg: #ffffff;
            --code-text: #333;
            --canvas-bg: #f8f8f8;
            --preview-bg: #ffffff;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            overflow: hidden;
            height: 100vh;
            transition: background-color 0.3s, color 0.3s;
        }
        
        .app-container {
            height: 100vh;
            display: flex;
            flex-direction: column;
        }
        
        /* Top Toolbar */
        .toolbar {
            height: 48px;
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border-color);
            display: flex;
            align-items: center;
            padding: 0 16px;
            gap: 8px;
            transition: background-color 0.3s, border-color 0.3s;
        }
        
        .tool-button {
            background: var(--bg-hover);
            border: 1px solid var(--border-hover);
            color: var(--text-secondary);
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 13px;
            display: flex;
            align-items: center;
            gap: 6px;
            transition: all 0.2s;
        }
        
        .tool-button:hover {
            background: var(--bg-active);
            color: var(--text-primary);
        }
        
        .tool-separator {
            width: 1px;
            height: 24px;
            background: var(--border-color);
            margin: 0 8px;
        }
        
        /* Theme Toggle */
        .theme-toggle {
            margin-left: auto;
            background: var(--bg-hover);
            border: 1px solid var(--border-hover);
            border-radius: 20px;
            padding: 4px;
            display: flex;
            gap: 4px;
            cursor: pointer;
        }
        
        .theme-option {
            padding: 4px 12px;
            border-radius: 16px;
            font-size: 12px;
            color: var(--text-tertiary);
            transition: all 0.2s;
        }
        
        .theme-option.active {
            background: var(--accent-primary);
            color: white;
        }
        
        /* Main Content */
        .main-content {
            flex: 1;
            display: flex;
            overflow: hidden;
            position: relative;
        }
        
        /* Shape Panel */
        .shape-panel {
            width: 200px;
            background: var(--bg-secondary);
            border-right: 1px solid var(--border-color);
            overflow-y: auto;
            flex-shrink: 0;
            transition: all 0.3s;
        }
        
        .shape-panel.collapsed {
            width: 0;
            overflow: hidden;
        }
        
        .panel-toggle {
            position: absolute;
            left: 200px;
            top: 50%;
            transform: translateY(-50%);
            width: 24px;
            height: 48px;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-left: none;
            border-radius: 0 8px 8px 0;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            z-index: 10;
            transition: all 0.3s;
        }
        
        .panel-toggle:hover {
            background: var(--bg-hover);
        }
        
        .shape-panel.collapsed ~ .panel-toggle {
            left: 0;
        }
        
        .panel-header {
            padding: 16px;
            background: var(--accent-primary);
            border-bottom: 1px solid var(--border-color);
            color: white;
        }
        
        .panel-header h3 {
            font-size: 14px;
            font-weight: 600;
        }
        
        .panel-header p {
            font-size: 11px;
            color: rgba(255,255,255,0.8);
            margin-top: 4px;
        }
        
        .shape-section {
            padding: 16px;
            border-bottom: 1px solid var(--border-color);
            overflow: visible;
        }
        
        .section-title {
            font-size: 12px;
            color: var(--text-primary);
            margin-bottom: 12px;
            text-transform: uppercase;
            font-weight: 600;
            background: var(--bg-hover);
            padding: 6px 10px;
            margin: -16px -16px 12px -16px;
            border-bottom: 1px solid var(--accent-primary);
        }
        
        .shape-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            margin-bottom: 20px;
        }
        
        .shape-item {
            aspect-ratio: 1;
            background: var(--bg-hover);
            border: 2px solid var(--border-hover);
            border-radius: 4px;
            cursor: move;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.15s;
            position: relative;
            min-height: 70px;
        }
        
        .shape-item:hover {
            background: var(--accent-primary);
            border-color: var(--accent-hover);
            transform: scale(1.05);
        }
        
        .shape-item.selected {
            background: var(--accent-primary);
            border-color: var(--accent-hover);
            box-shadow: 0 0 10px rgba(0, 123, 255, 0.3);
        }
        
        .shape-item.dragging {
            opacity: 0.5;
        }
        
        .shape-item::after {
            content: attr(title);
            position: absolute;
            bottom: -25px;
            left: 50%;
            transform: translateX(-50%);
            background: var(--bg-tertiary);
            color: var(--text-primary);
            padding: 4px 8px;
            border-radius: 3px;
            font-size: 10px;
            white-space: nowrap;
            opacity: 0;
            transition: opacity 0.2s;
            pointer-events: none;
            z-index: 100;
            border: 1px solid var(--border-color);
        }
        
        .shape-item:hover::after {
            opacity: 1;
        }
        
        .shape-preview {
            width: 50%;
            height: 35%;
            background: var(--text-primary);
            border-radius: 2px;
            pointer-events: none;
        }
        
        .shape-preview.round {
            border-radius: 50%;
        }
        
        .shape-preview.stadium {
            border-radius: 20px;
        }
        
        .shape-preview.subroutine {
            border: 3px double var(--text-primary);
            background: transparent;
            width: 60%;
            height: 40%;
        }
        
        .shape-preview.diamond {
            transform: rotate(45deg);
            width: 35%;
            height: 35%;
        }
        
        .shape-preview.hexagon {
            clip-path: polygon(30% 0%, 70% 0%, 100% 50%, 70% 100%, 30% 100%, 0% 50%);
        }
        
        .shape-preview.parallelogram {
            transform: skewX(-20deg);
        }
        
        .shape-preview.trapezoid {
            clip-path: polygon(20% 0%, 80% 0%, 100% 100%, 0% 100%);
        }
        
        .shape-preview.trapezoid-alt {
            clip-path: polygon(0% 0%, 100% 0%, 80% 100%, 20% 100%);
        }
        
        .shape-preview.cylinder {
            border-radius: 50%/20%;
            height: 50%;
        }
        
        /* Workspace */
        .workspace {
            flex: 1;
            display: flex;
            min-width: 0;
            transition: all 0.3s ease;
            position: relative;
        }
        
        /* Editor Area */
        .editor-area {
            flex: 1;
            display: flex;
            min-width: 0;
            position: relative;
            gap: 8px; /* Small gap to prevent overlap */
            overflow: hidden;
        }
        
        /* Resize Handle */
        .resize-handle {
            width: 16px;
            background: transparent;
            cursor: ew-resize;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
            transition: background 0.2s;
        }
        
        .resize-handle:hover {
            background: var(--bg-hover);
        }
        
        .resize-handle::before {
            content: '';
            position: absolute;
            width: 3px;
            height: 60px;
            background: var(--border-color);
            border-radius: 3px;
            transition: all 0.2s;
        }
        
        .resize-handle:hover::before {
            background: var(--accent-primary);
            height: 80px;
        }
        
        .resize-handle::after {
            content: '⋮';
            position: absolute;
            color: var(--text-tertiary);
            font-size: 18px;
            font-weight: bold;
            opacity: 0;
            transition: opacity 0.2s;
        }
        
        .resize-handle:hover::after {
            opacity: 1;
        }
        
        .canvas-container {
            flex: 1;
            background: var(--canvas-bg);
            position: relative;
            overflow: auto;
            margin: 16px 12px 16px 16px; /* Better spacing to prevent overlap */
            border-radius: 8px;
            transition: background-color 0.3s;
            min-width: 350px; /* Increased minimum width */
            max-width: calc(100% - 28px); /* Ensure it doesn't exceed container */
        }
        
        /* Modern Scrollbar Styles */
        .canvas-container::-webkit-scrollbar,
        .shape-panel::-webkit-scrollbar,
        .properties-panel::-webkit-scrollbar {
            width: 12px;
            height: 12px;
        }
        
        /* スクロールバーコーナーを非表示にする */
        .canvas-container::-webkit-scrollbar-corner,
        .shape-panel::-webkit-scrollbar-corner,
        .properties-panel::-webkit-scrollbar-corner {
            background: transparent;
            display: none;
        }

        /* Firefox用 */
        .canvas-container,
        .shape-panel,
        .properties-panel {
            scrollbar-color: var(--border-hover) transparent;
            scrollbar-width: thin;
        }

        .canvas-container::-webkit-scrollbar-track,
        .shape-panel::-webkit-scrollbar-track,
        .properties-panel::-webkit-scrollbar-track {
            background: var(--bg-tertiary);
            border-radius: 8px;
        }
        
        .canvas-container::-webkit-scrollbar-thumb,
        .shape-panel::-webkit-scrollbar-thumb,
        .properties-panel::-webkit-scrollbar-thumb {
            background: var(--border-hover);
            border-radius: 8px;
            border: 2px solid var(--bg-tertiary);
        }
        
        .canvas-container::-webkit-scrollbar-thumb:hover,
        .shape-panel::-webkit-scrollbar-thumb:hover,
        .properties-panel::-webkit-scrollbar-thumb:hover {
            background: var(--text-tertiary);
        }
        
        #canvas {
            position: relative;
            width: 2000px;
            height: 2000px;
            background-image: radial-gradient(circle, var(--grid-color) 1px, transparent 1px);
            background-size: 20px 20px;
            transition: background-image 0.3s;
            background-color: transparent;
        }
        
        #connectionSvg {
            position: absolute;
            top: 0;
            left: 0;
            width: 2000px;
            height: 2000px;
            pointer-events: none;
            z-index: 5;
        }
        
        #connectionSvg * {
            pointer-events: auto;
        }
        
        /* Nodes */
        .node {
            position: absolute;
            min-width: 120px;
            min-height: 60px;
            padding: 16px 24px;
            background: var(--accent-primary);
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: move;
            user-select: none;
            font-size: 14px;
            font-weight: 500;
            transition: transform 0.15s;
            box-shadow: 0 2px 8px var(--node-shadow);
            text-align: center;
            z-index: 10;
        }
        
        .node:hover {
            transform: scale(1.05);
        }
        
        .node.selected {
            outline: 2px solid var(--accent-hover);
            outline-offset: 4px;
        }
        
        /* For nodes inside wrappers, don't show the regular outline */
        .node-wrapper .node.selected {
            outline: none;
        }
        
        /* Override the default outline for clip-path shapes to show shape-specific outlines */
        .node.hexagon.selected,
        .node.trapezoid.selected,
        .node.trapezoid-alt.selected {
            outline: none;
        }
        
        .node.rectangle {
            border-radius: 4px;
        }
        
        .node.round {
            border-radius: 50%;
            min-width: 100px;
            min-height: 100px;
        }
        
        .node.stadium {
            border-radius: 30px;
        }
        
        .node.subroutine {
            border: 3px double white;
        }
        
        .node.diamond {
            transform: rotate(45deg);
            min-width: 100px;
            min-height: 100px;
        }
        
        .node.diamond .node-text {
            transform: rotate(-45deg);
        }
        
        .node.hexagon {
            clip-path: polygon(30% 0%, 70% 0%, 100% 50%, 70% 100%, 30% 100%, 0% 50%);
            min-width: 140px;
        }
        
        /* Selection outline for hexagon - works for both wrapped and unwrapped */
        .node-wrapper.selected .node.hexagon,
        .node.hexagon.selected {
            position: relative;
        }
        
        .node-wrapper.selected .node.hexagon::after,
        .node.hexagon.selected::after {
            content: '';
            position: absolute;
            top: -4px;
            left: -4px;
            right: -4px;
            bottom: -4px;
            background: transparent;
            border: 3px solid var(--accent-hover) !important;
            clip-path: polygon(30% 0%, 70% 0%, 100% 50%, 70% 100%, 30% 100%, 0% 50%);
            pointer-events: none;
            z-index: 100;
            border-radius: 0;
        }
        
        /* Remove rectangular outline from wrapper - let shape-specific outlines handle it */
        .node-wrapper.selected {
            /* No outline here - individual shapes handle their own outlines */
            outline: none !important;
        }
        
        .node.parallelogram {
            transform: skewX(-20deg);
        }
        
        .node.parallelogram .node-text {
            transform: skewX(20deg);
        }
        
        .node.trapezoid {
            clip-path: polygon(20% 0%, 80% 0%, 100% 100%, 0% 100%);
        }
        
        /* Selection outline for trapezoid (manual process) - works for both wrapped and unwrapped */
        .node-wrapper.selected .node.trapezoid,
        .node.trapezoid.selected {
            position: relative;
        }
        
        .node-wrapper.selected .node.trapezoid::after,
        .node.trapezoid.selected::after {
            content: '';
            position: absolute;
            top: -4px;
            left: -4px;
            right: -4px;
            bottom: -4px;
            background: transparent;
            border: 3px solid var(--accent-hover) !important;
            clip-path: polygon(20% 0%, 80% 0%, 100% 100%, 0% 100%);
            pointer-events: none;
            z-index: 100;
        }
        
        .node.trapezoid-alt {
            clip-path: polygon(0% 0%, 100% 0%, 80% 100%, 20% 100%);
        }
        
        /* Selection outline for trapezoid-alt (manual input) - works for both wrapped and unwrapped */
        .node-wrapper.selected .node.trapezoid-alt,
        .node.trapezoid-alt.selected {
            position: relative;
        }
        
        .node-wrapper.selected .node.trapezoid-alt::after,
        .node.trapezoid-alt.selected::after {
            content: '';
            position: absolute;
            top: -4px;
            left: -4px;
            right: -4px;
            bottom: -4px;
            background: transparent;
            border: 3px solid var(--accent-hover) !important;
            clip-path: polygon(0% 0%, 100% 0%, 80% 100%, 20% 100%);
            pointer-events: none;
            z-index: 100;
        }
        
        .node.cylinder {
            border-radius: 50%/20%;
            min-height: 80px;
        }
        
        /* Node Text Editing */
        .node-text {
            outline: none;
            background: transparent;
            border: none;
            color: inherit;
            font: inherit;
            text-align: center;
            width: 100%;
            cursor: move;
        }
        
        .node-text.editing {
            cursor: text;
            background: rgba(255,255,255,0.1);
            padding: 4px 8px;
            border-radius: 4px;
        }
        
        /* Node Controls */
        .node-controls {
            position: absolute;
            top: -15px;
            right: -15px;
            display: none;
            gap: 4px;
            z-index: 30;
        }
        
        .node:hover .node-controls {
            display: flex;
        }
        
        .node-delete {
            width: 24px;
            height: 24px;
            background: #f5222d;
            border: 2px solid #fff;
            border-radius: 50%;
            color: white;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: bold;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
            position: relative;
        }
        
        .node-delete:hover {
            background: #cf1322;
            transform: scale(1.1);
        }
        
        /* Fix positions for transformed nodes */
        .node.diamond .node-controls,
        .node.diamond .connection-point {
            transform: rotate(-45deg);
        }
        
        .node.parallelogram .node-controls,
        .node.parallelogram .connection-point {
            transform: skewX(20deg);
        }

        /* Node wrapper for clip-path shapes */
        .node-wrapper {
            position: absolute;
            z-index: 10;
            min-width: 120px;
            min-height: 60px;
        }

        /* Selection for wrapped nodes - don't add outline here, let shape-specific styles handle it */
        .node-wrapper.selected {
            position: relative;
            outline: none !important;
        }

        .node-wrapper .node {
            position: relative !important;
            left: 0 !important;
            top: 0 !important;
            width: 100%;
            height: 100%;
        }
        
        /* Connection points positioning for wrapped nodes */
        .node-wrapper .connection-point {
            position: absolute;
            width: 12px;
            height: 12px;
            background: var(--accent-hover);
            border: 2px solid #fff;
            border-radius: 50%;
            cursor: crosshair;
            opacity: 0;
            transition: opacity 0.15s;
            z-index: 20;
        }
        
        .node-wrapper:hover .connection-point {
            opacity: 1;
        }
        
        .node-wrapper .connection-point.top {
            top: -6px;
            left: 50%;
            transform: translateX(-50%);
        }
        
        .node-wrapper .connection-point.right {
            right: -6px;
            top: 50%;
            transform: translateY(-50%);
        }
        
        .node-wrapper .connection-point.bottom {
            bottom: -6px;
            left: 50%;
            transform: translateX(-50%);
        }
        
        .node-wrapper .connection-point.left {
            left: -6px;
            top: 50%;
            transform: translateY(-50%);
        }
        
        /* Controls positioning for wrapped nodes */
        .node-wrapper .node-controls {
            position: absolute;
            top: -15px;
            right: -15px;
            display: none;
            gap: 4px;
            z-index: 30;
        }
        
        .node-wrapper:hover .node-controls {
            display: flex;
        }
        
        /* Connection Points */
        .connection-point {
            position: absolute;
            width: 12px;
            height: 12px;
            background: var(--accent-hover);
            border: 2px solid #fff;
            border-radius: 50%;
            cursor: crosshair;
            opacity: 0;
            transition: opacity 0.15s;
            z-index: 10;
        }
        
        .node:hover .connection-point {
            opacity: 1;
        }
        
        .connection-point.top {
            top: -6px;
            left: 50%;
            transform: translateX(-50%);
        }
        
        .connection-point.right {
            right: -6px;
            top: 50%;
            transform: translateY(-50%);
        }
        
        .connection-point.bottom {
            bottom: -6px;
            left: 50%;
            transform: translateX(-50%);
        }
        
        .connection-point.left {
            left: -6px;
            top: 50%;
            transform: translateY(-50%);
        }
        
        /* Preview Area */
        .preview-area {
            width: 50%;
            display: flex;
            flex-direction: column;
            padding: 16px 24px 16px 16px; /* Proper spacing for all screen sizes */
            min-width: 350px; /* Increased minimum width for better layout */
            max-width: 60%; /* Prevent taking too much space on large screens */
            flex-shrink: 1; /* Allow shrinking when needed */
            box-sizing: border-box;
            position: relative;
            z-index: 1;
        }
        
        .preview-container {
            flex: 1;
            background: var(--bg-secondary);
            border-radius: 8px;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            margin-bottom: 16px;
            transition: background-color 0.3s;
            border: 1px solid var(--border-color);
        }
        
        .preview-header {
            padding: 12px 16px;
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border-color);
            font-size: 13px;
            font-weight: 500;
            transition: background-color 0.3s, border-color 0.3s;
        }
        
        .preview-content {
            flex: 1;
            padding: 24px;
            overflow: auto;
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 300px;
            background: var(--preview-bg, var(--bg-secondary));
        }
        
        #mermaidPreview {
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
            overflow: hidden;
        }
        
        #mermaidPreview svg {
            max-width: 100%;
            max-height: 100%;
            width: auto !important;
            height: auto !important;
        }
        
        .mermaid {
            display: flex;
            justify-content: center;
            align-items: center;
            width: 100%;
            height: 100%;
            overflow: hidden;
        }
        
        /* Disable hover effects on Mermaid elements */
        .mermaid .node rect,
        .mermaid .node circle,
        .mermaid .node ellipse,
        .mermaid .node polygon,
        .mermaid .node path {
            cursor: default !important;
        }
        
        .mermaid .node:hover {
            transform: none !important;
        }
        
        .mermaid .edgePath path:hover {
            stroke-width: 2 !important;
        }
        
        .code-container {
            background: var(--bg-secondary);
            border-radius: 8px;
            overflow: hidden;
            transition: background-color 0.3s;
            border: 1px solid var(--border-color);
        }
        
        .code-header {
            padding: 8px 16px;
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border-color);
            font-size: 12px;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: background-color 0.3s, border-color 0.3s;
        }
        
        .code-editor {
            padding: 16px;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 13px;
            color: var(--code-text);
            overflow: auto;
            white-space: pre;
            height: 300px;
            max-height: 300px;
            background: var(--code-bg);
            transition: background-color 0.3s, color 0.3s;
        }
        
        .code-container.collapsed .code-editor {
            display: none;
        }
        
        /* Properties Panel */
        .properties-panel {
            width: 280px;
            background: var(--bg-secondary);
            border-left: 1px solid var(--border-color);
            overflow-y: auto;
            flex-shrink: 0;
            transition: background-color 0.3s, border-color 0.3s;
        }
        
        .property-group {
            padding: 16px;
            border-bottom: 1px solid var(--border-color);
        }
        
        .property-label {
            font-size: 12px;
            color: var(--text-tertiary);
            margin-bottom: 6px;
        }
        
        .property-input {
            width: 100%;
            padding: 8px;
            background: var(--bg-hover);
            border: 1px solid var(--border-hover);
            color: var(--text-primary);
            border-radius: 4px;
            font-size: 13px;
            transition: all 0.2s;
        }
        
        .property-input:focus {
            outline: none;
            border-color: var(--accent-primary);
        }
        
        .color-grid {
            display: grid;
            grid-template-columns: repeat(6, 1fr);
            gap: 8px;
            margin-top: 8px;
        }
        
        .color-option {
            width: 32px;
            height: 32px;
            border-radius: 4px;
            cursor: pointer;
            border: 2px solid transparent;
            transition: all 0.15s;
        }
        
        .color-option:hover {
            transform: scale(1.1);
        }
        
        .color-option.selected {
            border-color: var(--text-primary);
        }
        
        /* Connection Properties */
        .connection-style-options {
            display: flex;
            gap: 8px;
            margin-top: 8px;
        }
        
        .style-option {
            flex: 1;
            padding: 8px;
            background: var(--bg-hover);
            border: 1px solid var(--border-hover);
            border-radius: 4px;
            text-align: center;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.2s;
        }
        
        .style-option:hover {
            background: var(--bg-active);
        }
        
        .style-option.selected {
            background: var(--accent-primary);
            border-color: var(--accent-primary);
            color: white;
        }
        
        /* Subgraph */
        .subgraph {
            position: absolute;
            border: 2px dashed var(--text-tertiary);
            border-radius: 8px;
            background: rgba(128,128,128,0.05);
            padding: 32px 16px 16px 16px;
            min-width: 250px;
            min-height: 200px;
            cursor: move;
            z-index: 1;
        }
        
        .subgraph.selected {
            border-color: var(--accent-hover);
            background: rgba(64,169,255,0.1);
        }
        
        .subgraph-title {
            position: absolute;
            top: 8px;
            left: 16px;
            font-size: 14px;
            color: var(--text-primary);
            font-weight: 600;
            background: transparent;
            border: none;
            outline: none;
            cursor: move;
            padding: 4px 8px;
            border-radius: 4px;
        }
        
        .subgraph-title.editing {
            background: var(--bg-hover);
            cursor: text;
        }
        
        .subgraph-delete {
            position: absolute;
            top: 8px;
            right: 8px;
            width: 24px;
            height: 24px;
            background: #f5222d;
            border: 2px solid #fff;
            border-radius: 50%;
            color: white;
            cursor: pointer;
            display: none;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: bold;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
            z-index: 20;
        }
        
        .subgraph:hover .subgraph-delete {
            display: flex;
        }
        
        .subgraph-delete:hover {
            background: #cf1322;
        }
        
        .subgraph-resize {
            position: absolute;
            bottom: 0;
            right: 0;
            width: 20px;
            height: 20px;
            cursor: se-resize;
            background: transparent;
            opacity: 0;
            transition: opacity 0.2s;
        }
        
        .subgraph:hover .subgraph-resize {
            opacity: 1;
        }
        
        .subgraph-resize::after {
            content: '';
            position: absolute;
            bottom: 2px;
            right: 2px;
            width: 0;
            height: 0;
            border-style: solid;
            border-width: 0 0 10px 10px;
            border-color: transparent transparent var(--text-tertiary) transparent;
        }
        
        .subgraph:hover .subgraph-resize::after {
            border-color: transparent transparent var(--accent-hover) transparent;
        }
        
        .creating-subgraph {
            border: 2px dashed var(--accent-hover);
            background: rgba(64,169,255,0.1);
            pointer-events: none;
        }
        
        .connection-line {
            stroke: var(--connection-color);
            stroke-width: 2;
            fill: none;
            transition: stroke 0.15s;
            pointer-events: stroke;
            cursor: pointer;
        }
        
        .connection-line:hover {
            stroke: var(--accent-hover);
            stroke-width: 3;
        }
        
        .connection-line.dotted {
            stroke-dasharray: 5,5;
        }
        
        .connection-label {
            fill: var(--text-primary);
            font-size: 12px;
            font-weight: 500;
            text-anchor: middle;
            pointer-events: none;
            background: var(--bg-primary);
            padding: 2px 4px;
        }
        
        .connection-label-bg {
            fill: var(--bg-primary);
            stroke: var(--border-color);
            stroke-width: 1;
            rx: 3;
            ry: 3;
        }
        
        .connection-delete-btn {
            display: none;
            position: absolute;
            width: 20px;
            height: 20px;
            background: #f5222d;
            border: 2px solid #fff;
            border-radius: 50%;
            color: white;
            cursor: pointer;
            font-size: 12px;
            font-weight: bold;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
            z-index: 20;
            pointer-events: auto;
        }
        
        .connection-delete-btn:hover {
            background: #cf1322;
            transform: scale(1.1);
        }
        
        .connection-group:hover .connection-delete-btn {
            display: flex;
        }
        
        .temp-connection {
            stroke: var(--accent-hover);
            stroke-width: 2;
            stroke-dasharray: 5,5;
            fill: none;
        }
        
        /* Drag Ghost */
        .drag-ghost {
            position: fixed;
            pointer-events: none;
            z-index: 1000;
            opacity: 0.8;
        }
        
        /* Modal */
        .modal {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 24px;
            z-index: 1000;
            box-shadow: 0 8px 32px rgba(0,0,0,0.5);
            transition: background-color 0.3s, border-color 0.3s;
        }
        
        .modal-backdrop {
            display: none;
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.5);
            z-index: 999;
        }
        
        .direction-options {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            margin-top: 16px;
        }
        
        .direction-btn {
            padding: 12px;
            background: var(--bg-hover);
            border: 1px solid var(--border-hover);
            color: var(--text-primary);
            border-radius: 4px;
            cursor: pointer;
            font-size: 13px;
            transition: all 0.15s;
        }
        
        .direction-btn:hover {
            background: var(--bg-active);
        }
        
        .direction-btn.selected {
            background: var(--accent-primary);
            border-color: var(--accent-primary);
            color: white;
        }
    
/* === Custom fixes 2025-08-03 === */
.preview-area { margin-right: 16px; }
.node-wrapper { overflow: visible; }
/* Disable resize handle completely */
.resize-handle { display: none !important; }
/* Ensure outlines for clip‑path shapes render above other elements */
.node.hexagon::after,
.node.trapezoid::after,
.node.trapezoid-alt::after { pointer-events: none; }
/* ================================= */
</style>
</head>
<body>
    <div class="app-container">
        <!-- Toolbar -->
        <div class="toolbar">
            <button class="tool-button" onclick="showDirectionModal()">
                <span style="opacity: 0.7;">↕</span> Direction
            </button>
            <button class="tool-button" onclick="toggleSubgraphMode()">
                <span style="opacity: 0.7;">▢</span> Subgraph
            </button>
            <div class="tool-separator"></div>
            <button class="tool-button" onclick="clearCanvas()">
                <span style="opacity: 0.7;">×</span> Clear All
            </button>
            <div class="tool-separator"></div>
            <button class="tool-button" onclick="copyCode()">
                <span style="opacity: 0.7;">⎘</span> Copy Code
            </button>
            <button class="tool-button" onclick="exportSVG()">
                <span style="opacity: 0.7;">↓</span> Export SVG
            </button>
            
            <!-- Theme Toggle -->
            <div class="theme-toggle" onclick="toggleTheme()">
                <div class="theme-option dark-option active">Dark</div>
                <div class="theme-option light-option">Light</div>
            </div>
        </div>
        
        <div class="main-content">
            <!-- Shape Panel -->
            <div class="shape-panel" id="shapePanel">
                <div class="panel-header">
                    <h3>Shape Palette</h3>
                    <p>Drag to canvas</p>
                </div>
                
                <div class="shape-section">
                    <div class="section-title">Basic Shapes</div>
                    <div class="shape-grid">
                        <div class="shape-item" draggable="true" data-shape="rectangle" title="Rectangle">
                            <div class="shape-preview"></div>
                        </div>
                        <div class="shape-item" draggable="true" data-shape="round" title="Circle">
                            <div class="shape-preview round"></div>
                        </div>
                        <div class="shape-item" draggable="true" data-shape="stadium" title="Stadium">
                            <div class="shape-preview stadium"></div>
                        </div>
                        <div class="shape-item" draggable="true" data-shape="subroutine" title="Subroutine">
                            <div class="shape-preview subroutine"></div>
                        </div>
                        <div class="shape-item" draggable="true" data-shape="diamond" title="Decision">
                            <div class="shape-preview diamond"></div>
                        </div>
                        <div class="shape-item" draggable="true" data-shape="hexagon" title="Hexagon">
                            <div class="shape-preview hexagon"></div>
                        </div>
                        <div class="shape-item" draggable="true" data-shape="parallelogram" title="Input/Output">
                            <div class="shape-preview parallelogram"></div>
                        </div>
                        <div class="shape-item" draggable="true" data-shape="trapezoid" title="Manual Process">
                            <div class="shape-preview trapezoid"></div>
                        </div>
                        <div class="shape-item" draggable="true" data-shape="trapezoid-alt" title="Manual Input">
                            <div class="shape-preview trapezoid-alt"></div>
                        </div>
                        <div class="shape-item" draggable="true" data-shape="cylinder" title="Database">
                            <div class="shape-preview cylinder"></div>
                        </div>
                    </div>
                </div>
                
                <div class="shape-section">
                    <div class="section-title">Groups</div>
                    <button class="tool-button" style="width: 100%;" onclick="createQuickSubgraph()">
                        Add Group
                    </button>
                </div>
            </div>
            
            <!-- Panel Toggle -->
            <div class="panel-toggle" onclick="togglePanel()">
                <span id="panelToggleIcon">◀</span>
            </div>
            
            <!-- Workspace -->
            <div class="workspace">
                <div class="editor-area">
                    <!-- Canvas -->
                    <div class="canvas-container" id="canvasContainer">
                        <div id="canvas">
                            <svg id="connectionSvg"></svg>
                        </div>
                    </div>
                    
                    <!-- Resize Handle -->
                    
                    <!-- Preview -->
                    <div class="preview-area">
                        <div class="preview-container">
                            <div class="preview-header">Preview</div>
                            <div class="preview-content">
                                <div id="mermaidPreview"></div>
                            </div>
                        </div>
                        
                        <div class="code-container" id="codeContainer">
                            <div class="code-header" onclick="toggleCodeView()">
                                <span>Mermaid Code</span>
                                <span id="toggleIcon">▼</span>
                            </div>
                            <div class="code-editor" id="mermaidCode">graph TD</div>
                        </div>
                    </div>
                </div>
                
                <!-- Properties Panel -->
                <div class="properties-panel">
                    <div class="property-group">
                        <div class="section-title">Selected Element</div>
                        <div id="selectedInfo" style="color: var(--text-tertiary); font-size: 12px;">None</div>
                    </div>
                    
                    <div class="property-group" id="nodeProperties" style="display: none;">
                        <div class="property-label">Text</div>
                        <input type="text" class="property-input" id="nodeText" oninput="updateNodeText()">
                        
                        <div class="property-label" style="margin-top: 12px;">Background Color</div>
                        <div class="color-grid">
                            <div class="color-option" style="background: #007acc;" onclick="setNodeColor('#007acc')"></div>
                            <div class="color-option" style="background: #40a9ff;" onclick="setNodeColor('#40a9ff')"></div>
                            <div class="color-option" style="background: #52c41a;" onclick="setNodeColor('#52c41a')"></div>
                            <div class="color-option" style="background: #faad14;" onclick="setNodeColor('#faad14')"></div>
                            <div class="color-option" style="background: #f5222d;" onclick="setNodeColor('#f5222d')"></div>
                            <div class="color-option" style="background: #722ed1;" onclick="setNodeColor('#722ed1')"></div>
                        </div>
                        
                        <div style="margin-top: 12px; display: flex; gap: 8px; align-items: center;">
                            <input type="color" id="colorPicker" value="#007acc" style="width: 50px; height: 36px; border: 1px solid var(--border-hover); border-radius: 4px; cursor: pointer; background: var(--bg-hover);" onchange="setNodeColor(this.value)">
                            <input type="text" id="colorInput" placeholder="#000000" style="flex: 1; padding: 8px 10px; background: var(--bg-hover); border: 1px solid var(--border-hover); color: var(--text-primary); border-radius: 4px; font-size: 14px; font-family: 'Consolas', 'Monaco', monospace; font-weight: 500;" onkeyup="handleColorInput(event)">
                        </div>
                    </div>
                    
                    <div class="property-group" id="connectionProperties" style="display: none;">
                        <div class="property-label">Connection Type</div>
                        <div class="connection-style-options">
                            <div class="style-option selected" onclick="setConnectionStyle('arrow')">→</div>
                            <div class="style-option" onclick="setConnectionStyle('double')">↔</div>
                            <div class="style-option" onclick="setConnectionStyle('none')">—</div>
                        </div>
                        
                        <div class="property-label" style="margin-top: 12px;">Line Style</div>
                        <div class="connection-style-options">
                            <div class="style-option selected" onclick="setLineStyle('solid')">━━</div>
                            <div class="style-option" onclick="setLineStyle('dotted')">┅┅</div>
                        </div>
                        
                        <div class="property-label" style="margin-top: 12px;">Label</div>
                        <input type="text" class="property-input" id="connectionLabel" placeholder="Connection label" oninput="updateConnectionLabel()">
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Direction Modal -->
    <div class="modal-backdrop" id="modalBackdrop" onclick="closeModal()"></div>
    <div class="modal" id="directionModal">
        <div class="section-title" style="margin-bottom: 16px;">Flow Direction</div>
        <div class="direction-options">
            <button class="direction-btn" onclick="setDirection('TD')">↓ Top to Bottom</button>
            <button class="direction-btn" onclick="setDirection('LR')">→ Left to Right</button>
            <button class="direction-btn" onclick="setDirection('BT')">↑ Bottom to Top</button>
            <button class="direction-btn" onclick="setDirection('RL')">← Right to Left</button>
        </div>
    </div>

    <script>
        // State
        let nodes = [];
        let connections = [];
        let subgraphs = [];
        let nodeIdCounter = 0;
        let subgraphIdCounter = 0;
        let connectionIdCounter = 0;
        let selectedNode = null;
        let selectedSubgraph = null;
        let selectedConnection = null;
        let flowDirection = 'TD';
        let isDragging = false;
        let draggedNode = null;
        let offset = { x: 0, y: 0 };
        let isConnecting = false;
        let connectionStart = null;
        let tempLine = null;
        let dragGhost = null;
        let subgraphMode = false;
        let currentTheme = 'dark';
        
        // Theme Toggle
        function toggleTheme() {
            currentTheme = currentTheme === 'dark' ? 'light' : 'dark';
            document.body.classList.toggle('light-mode');
            
            const darkOption = document.querySelector('.dark-option');
            const lightOption = document.querySelector('.light-option');
            
            if (currentTheme === 'dark') {
                darkOption.classList.add('active');
                lightOption.classList.remove('active');
            } else {
                darkOption.classList.remove('active');
                lightOption.classList.add('active');
            }
            
            // Re-initialize Mermaid with new theme
            initializeMermaid();

// Ensure all UI panels reflow correctly after side panel transitions
document.getElementById('shapePanel').addEventListener('transitionend', () => {
    updateConnections();
    window.dispatchEvent(new Event('resize'));
}, { once: true });

            updateMermaidCode();
        }
        
        // Panel Toggle
        function togglePanel() {
            const panel = document.getElementById('shapePanel');
            const icon = document.getElementById('panelToggleIcon');
            const workspace = document.querySelector('.workspace');
            const editorArea = document.querySelector('.editor-area');
            
            panel.classList.toggle('collapsed');
            icon.textContent = panel.classList.contains('collapsed') ? '▶' : '◀';
            
            // Force immediate layout recalculation
            if (panel.classList.contains('collapsed')) {
                workspace.style.marginLeft = '24px'; // Account for toggle button
                workspace.style.width = 'calc(100% - 24px)';
            } else {
                workspace.style.marginLeft = '0';
                workspace.style.width = '100%';
            }
            
            // Force layout reflow immediately
            workspace.offsetHeight; // Trigger reflow
            
            // Update connections and trigger resize events
            requestAnimationFrame(() => {
                updateConnections();
                window.dispatchEvent(new Event('resize'));
                
                // Double-check after another frame
                requestAnimationFrame(() => {
                    updateConnections();
                });
            });
        }
        
        // Throttle function for performance
        function throttle(func, delay) {
            let lastCall = 0;
            return function(...args) {
                const now = Date.now();
                if (now - lastCall >= delay) {
                    lastCall = now;
                    return func.apply(this, args);
                }
            };
        }
        
        // Initialize Mermaid
        function initializeMermaid() {
            const isDark = currentTheme === 'dark';
            mermaid.initialize({ 
                startOnLoad: false,
                theme: isDark ? 'dark' : 'default',
                themeVariables: isDark ? {
                    darkMode: true,
                    background: '#1e1e1e',
                    primaryColor: '#007acc',
                    primaryTextColor: '#fff',
                    primaryBorderColor: '#40a9ff',
                    lineColor: '#999',
                    secondaryColor: '#252526',
                    tertiaryColor: '#3c3c3c'
                } : {
                    primaryColor: '#0066cc',
                    primaryTextColor: '#1a1a1a',
                    primaryBorderColor: '#0052cc',
                    lineColor: '#666',
                    secondaryColor: '#f5f5f5',
                    tertiaryColor: '#f0f0f0'
                },
                flowchart: {
                    htmlLabels: true,
                    curve: 'linear'
                },
                securityLevel: 'loose',
                // Disable interactivity
                interaction: {
                    dragNodes: false,
                    zoomView: false,
                    panView: false
                }
            });
        }
        
        // Initialize Mermaid on load
        initializeMermaid();

        // Setup drag and drop for shape items
        document.querySelectorAll('.shape-item').forEach(item => {
            item.addEventListener('dragstart', handleShapeDragStart);
            item.addEventListener('dragend', handleShapeDragEnd);
            item.addEventListener('click', handleShapeClick);
        });

        // Setup drop zone on canvas
        const canvas = document.getElementById('canvas');
        canvas.addEventListener('dragover', handleCanvasDragOver);
        canvas.addEventListener('drop', handleCanvasDrop);

        // Shape selection
        let selectedShapeType = 'rectangle'; // Default selection
        
        function handleShapeClick(e) {
            // Remove previous selection
            document.querySelectorAll('.shape-item').forEach(item => {
                item.classList.remove('selected');
            });
            
            // Add selection to clicked item
            e.currentTarget.classList.add('selected');
            selectedShapeType = e.currentTarget.dataset.shape;
        }
        
        // Shape drag handlers
        function handleShapeDragStart(e) {
            e.dataTransfer.effectAllowed = 'copy';
            e.dataTransfer.setData('shape-type', e.currentTarget.dataset.shape);
            e.currentTarget.classList.add('dragging');
            
            // Also select the shape being dragged
            handleShapeClick(e);
            
            // Create custom drag image
            const ghost = e.currentTarget.cloneNode(true);
            ghost.style.position = 'absolute';
            ghost.style.top = '-1000px';
            document.body.appendChild(ghost);
            e.dataTransfer.setDragImage(ghost, 40, 40);
            setTimeout(() => ghost.remove(), 0);
        }

        function handleShapeDragEnd(e) {
            e.currentTarget.classList.remove('dragging');
        }

        function handleCanvasDragOver(e) {
            e.preventDefault();
            e.dataTransfer.dropEffect = 'copy';
        }

        function handleCanvasDrop(e) {
            e.preventDefault();
            const shapeType = e.dataTransfer.getData('shape-type');
            if (shapeType) {
                const canvasRect = canvas.getBoundingClientRect();
                const x = e.clientX - canvasRect.left;
                const y = e.clientY - canvasRect.top;
                addNode(shapeType, x - 60, y - 30);
            }
        }

        // Add Node
        function addNode(type, x, y) {
            const canvas = document.getElementById('canvas');
            const nodeId = `node${nodeIdCounter++}`;
            
            // Check if shape needs wrapper for clip-path
            const needsWrapper = ['hexagon', 'trapezoid', 'trapezoid-alt'].includes(type);
            
            let nodeElement;
            let innerNode;
            
            if (needsWrapper) {
                // Create wrapper element for connection points and delete button
                nodeElement = document.createElement('div');
                nodeElement.className = 'node-wrapper';
                nodeElement.id = nodeId;
                nodeElement.style.left = x + 'px';
                nodeElement.style.top = y + 'px';
                
                // Set wrapper dimensions based on node type
                let wrapperWidth = '120px';
                let wrapperHeight = '60px';
                
                if (type === 'hexagon') {
                    wrapperWidth = '140px';
                    wrapperHeight = '80px';
                } else if (type === 'trapezoid' || type === 'trapezoid-alt') {
                    wrapperWidth = '140px';
                    wrapperHeight = '70px';
                }
                
                nodeElement.style.width = wrapperWidth;
                nodeElement.style.height = wrapperHeight;
                
                // Create actual shape element
                innerNode = document.createElement('div');
                innerNode.className = `node ${type}`;
                nodeElement.appendChild(innerNode);
            } else {
                // Regular node
                nodeElement = document.createElement('div');
                nodeElement.className = `node ${type}`;
                nodeElement.id = nodeId;
                nodeElement.style.left = x + 'px';
                nodeElement.style.top = y + 'px';
                innerNode = nodeElement;
            }
            
            // Create text element
            const textEl = document.createElement('div');
            textEl.className = 'node-text';
            textEl.contentEditable = false;
            
            // Add text based on type
            let text = 'Process';
            switch(type) {
                case 'diamond': text = 'Decision'; break;
                case 'parallelogram': text = 'Input/Output'; break;
                case 'cylinder': text = 'Database'; break;
                case 'hexagon': text = 'Preparation'; break;
                case 'trapezoid': text = 'Manual Process'; break;
                case 'trapezoid-alt': text = 'Manual Input'; break;
                case 'subroutine': text = 'Subroutine'; break;
            }
            textEl.textContent = text;
            
            // Add double click handler for editing
            textEl.addEventListener('dblclick', (e) => {
                e.stopPropagation();
                startEditingNodeText(textEl, nodeId);
            });
            
            innerNode.appendChild(textEl);
            
            // Set initial color
            innerNode.style.background = '#007acc';
            
            // Add controls
            const controls = document.createElement('div');
            controls.className = 'node-controls';
            controls.innerHTML = '<div class="node-delete" onclick="deleteNode(event, \'' + nodeId + '\')">×</div>';
            nodeElement.appendChild(controls);
            
            // Add connection points
            ['top', 'right', 'bottom', 'left'].forEach(pos => {
                const point = document.createElement('div');
                point.className = `connection-point ${pos}`;
                point.onmousedown = (e) => startConnection(e, nodeId, pos);
                nodeElement.appendChild(point);
            });
            
            // Add event listeners
            nodeElement.addEventListener('mousedown', handleNodeMouseDown);
            nodeElement.addEventListener('click', handleNodeClick);
            
            canvas.appendChild(nodeElement);
            
            // データの保存時にラッパーかどうかの情報も保存
            nodes.push({
                id: nodeId,
                type: type,
                text: text,
                color: '#007acc',
                hasWrapper: needsWrapper
            });
            
            // Select the new node
            selectNode(nodeElement);
            
            updateMermaidCode();
        }

        // Start editing node text
        function startEditingNodeText(textEl, nodeId) {
            textEl.contentEditable = true;
            textEl.classList.add('editing');
            textEl.focus();
            
            // Select all text
            const range = document.createRange();
            range.selectNodeContents(textEl);
            const sel = window.getSelection();
            sel.removeAllRanges();
            sel.addRange(range);
            
            const finishEditing = () => {
                textEl.contentEditable = false;
                textEl.classList.remove('editing');
                const nodeData = nodes.find(n => n.id === nodeId);
                nodeData.text = textEl.textContent;
                updateMermaidCode();
            };
            
            textEl.addEventListener('blur', finishEditing, { once: true });
            textEl.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    textEl.blur();
                }
            });
        }

        // Node Events
        function handleNodeMouseDown(e) {
            if (e.target.classList.contains('connection-point') || 
                e.target.classList.contains('node-delete') ||
                e.target.classList.contains('editing')) return;
            
            isDragging = true;
            draggedNode = e.currentTarget;
            const rect = draggedNode.getBoundingClientRect();
            offset.x = e.clientX - rect.left;
            offset.y = e.clientY - rect.top;
            
            selectNode(draggedNode);
        }

        function handleNodeClick(e) {
            if (e.target.classList.contains('connection-point') || 
                e.target.classList.contains('node-delete')) return;
            
            e.stopPropagation();
            selectNode(e.currentTarget);
        }

        function selectNode(node) {
            // Deselect previous selections
            if (selectedNode) {
                selectedNode.classList.remove('selected');
                // Also remove from wrapper if exists
                if (selectedNode.classList.contains('node-wrapper')) {
                    selectedNode.classList.remove('selected');
                }
            }
            if (selectedConnection) {
                selectedConnection = null;
                document.getElementById('connectionProperties').style.display = 'none';
            }
            
            selectedNode = node;
            
            // For wrapped nodes, add selected to wrapper; for regular nodes, add to node itself
            if (node.classList.contains('node-wrapper')) {
                node.classList.add('selected');
            } else {
                node.classList.add('selected');
            }
            
            const nodeData = nodes.find(n => n.id === node.id);
            document.getElementById('selectedInfo').textContent = `Node: ${nodeData.text}`;
            document.getElementById('nodeProperties').style.display = 'block';
            document.getElementById('nodeText').value = nodeData.text;
            
            // Update color controls
            const color = nodeData.color || '#007acc';
            document.getElementById('colorPicker').value = color;
            document.getElementById('colorInput').value = color;
            
            // Update selected color indicator
            document.querySelectorAll('.color-option').forEach(opt => {
                opt.classList.remove('selected');
                if (opt.style.background === color || 
                    rgbToHex(opt.style.background) === color.toLowerCase()) {
                    opt.classList.add('selected');
                }
            });
        }

        // Delete Node
        function deleteNode(e, nodeId) {
            e.stopPropagation();
            const node = document.getElementById(nodeId);
            if (node) {
                node.remove();
                nodes = nodes.filter(n => n.id !== nodeId);
                connections = connections.filter(c => c.from !== nodeId && c.to !== nodeId);
                updateConnections();
                updateMermaidCode();
                
                if (selectedNode && selectedNode.id === nodeId) {
                    selectedNode = null;
                    document.getElementById('selectedInfo').textContent = 'None';
                    document.getElementById('nodeProperties').style.display = 'none';
                }
            }
        }

        // Connection Management
        function startConnection(e, nodeId, position) {
            e.stopPropagation();
            isConnecting = true;
            connectionStart = { nodeId, position };
            
            const svg = document.getElementById('connectionSvg');
            tempLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            tempLine.setAttribute('class', 'temp-connection');
            svg.appendChild(tempLine);
            
            updateTempConnection(e);
        }

        function updateTempConnection(e) {
            if (!tempLine || !connectionStart) return;
            
            const startNode = document.getElementById(connectionStart.nodeId);
            if (!startNode) return;
            
            const canvas = document.getElementById('canvas');
            const canvasRect = canvas.getBoundingClientRect();
            const container = canvas.parentElement;
            
            const startX = parseInt(startNode.style.left) + startNode.offsetWidth / 2;
            const startY = parseInt(startNode.style.top) + startNode.offsetHeight / 2;
            
            const mouseX = e.clientX - canvasRect.left + container.scrollLeft;
            const mouseY = e.clientY - canvasRect.top + container.scrollTop;
            
            tempLine.setAttribute('x1', startX);
            tempLine.setAttribute('y1', startY);
            tempLine.setAttribute('x2', mouseX);
            tempLine.setAttribute('y2', mouseY);
        }

        function createConnection(fromId, toId) {
            // Check if connection already exists
            const exists = connections.some(c => 
                (c.from === fromId && c.to === toId) || 
                (c.from === toId && c.to === fromId)
            );
            
            if (!exists) {
                const connectionId = `conn${connectionIdCounter++}`;
                connections.push({
                    id: connectionId,
                    from: fromId,
                    to: toId,
                    style: 'arrow',
                    lineStyle: 'solid',
                    label: ''
                });
                updateConnections();
                updateMermaidCode();
            }
        }
        
        function endConnection(e) {
            if (!isConnecting) return;
            
            // Find target node (check both .node and .node-wrapper)
            let target = e.target.closest('.node');
            if (!target) {
                target = e.target.closest('.node-wrapper');
            }
            
            // Get the actual node ID
            let targetId = null;
            if (target) {
                if (target.classList.contains('node-wrapper')) {
                    targetId = target.id;
                } else if (target.classList.contains('node')) {
                    // If it's a regular node, use its ID
                    // If it's inside a wrapper, use the wrapper's ID
                    const wrapper = target.closest('.node-wrapper');
                    targetId = wrapper ? wrapper.id : target.id;
                }
            }
            
            if (targetId && targetId !== connectionStart.nodeId) {
                createConnection(connectionStart.nodeId, targetId);
            }
            
            // Clean up
            if (tempLine) {
                tempLine.remove();
                tempLine = null;
            }
            isConnecting = false;
            connectionStart = null;
        }

        // Select connection
        function selectConnection(connId) {
            selectedConnection = connections.find(c => c.id === connId);
            if (selectedNode) {
                selectedNode.classList.remove('selected');
                selectedNode = null;
            }
            
            document.getElementById('selectedInfo').textContent = 'Connection';
            document.getElementById('nodeProperties').style.display = 'none';
            document.getElementById('connectionProperties').style.display = 'block';
            
            // Update UI
            document.getElementById('connectionLabel').value = selectedConnection.label || '';
            
            // Update style buttons
            document.querySelectorAll('.connection-style-options .style-option').forEach(opt => {
                opt.classList.remove('selected');
            });
            
            const styleMap = {
                'arrow': 0,
                'double': 1,
                'none': 2
            };
            const lineStyleMap = {
                'solid': 0,
                'dotted': 1
            };
            
            document.querySelectorAll('.connection-style-options')[0].children[styleMap[selectedConnection.style || 'arrow']].classList.add('selected');
            document.querySelectorAll('.connection-style-options')[1].children[lineStyleMap[selectedConnection.lineStyle || 'solid']].classList.add('selected');
        }

        // Connection style functions
        function setConnectionStyle(style) {
            if (!selectedConnection) return;
            selectedConnection.style = style;
            updateConnections();
            updateMermaidCode();
            
            // Update UI
            document.querySelectorAll('.connection-style-options')[0].querySelectorAll('.style-option').forEach(opt => {
                opt.classList.remove('selected');
            });
            event.target.classList.add('selected');
        }

        function setLineStyle(style) {
            if (!selectedConnection) return;
            selectedConnection.lineStyle = style;
            updateConnections();
            updateMermaidCode();
            
            // Update UI
            document.querySelectorAll('.connection-style-options')[1].querySelectorAll('.style-option').forEach(opt => {
                opt.classList.remove('selected');
            });
            event.target.classList.add('selected');
        }

        function updateConnectionLabel() {
            if (!selectedConnection) return;
            selectedConnection.label = document.getElementById('connectionLabel').value;
            updateConnections();
            updateMermaidCode();
        }

        // Update connections with improved edge calculation
        const updateConnections = throttle(function() {
            const svg = document.getElementById('connectionSvg');
            const canvas = document.getElementById('canvas');
            
            // Clear previous content
            while (svg.firstChild) {
                svg.removeChild(svg.firstChild);
            }
            
            // Remove old delete buttons
            canvas.querySelectorAll('.connection-delete-btn').forEach(btn => btn.remove());
            
            // Add arrow markers
            const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
            
            // Standard arrow
            const marker = document.createElementNS('http://www.w3.org/2000/svg', 'marker');
            marker.setAttribute('id', 'arrowhead');
            marker.setAttribute('markerWidth', '10');
            marker.setAttribute('markerHeight', '10');
            marker.setAttribute('refX', '9');
            marker.setAttribute('refY', '5');
            marker.setAttribute('orient', 'auto');
            marker.setAttribute('markerUnits', 'strokeWidth');
            
            const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            path.setAttribute('d', 'M0,0 L10,5 L0,10 L3,5 z');
            path.setAttribute('fill', 'var(--connection-color)');
            
            marker.appendChild(path);
            defs.appendChild(marker);
            
            // Reverse arrow
            const markerReverse = document.createElementNS('http://www.w3.org/2000/svg', 'marker');
            markerReverse.setAttribute('id', 'arrowhead-reverse');
            markerReverse.setAttribute('markerWidth', '10');
            markerReverse.setAttribute('markerHeight', '10');
            markerReverse.setAttribute('refX', '2');
            markerReverse.setAttribute('refY', '5');
            markerReverse.setAttribute('orient', 'auto');
            markerReverse.setAttribute('markerUnits', 'strokeWidth');
            
            const pathReverse = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            pathReverse.setAttribute('d', 'M0,0 L10,5 L0,10 L3,5 z');
            pathReverse.setAttribute('fill', 'var(--connection-color)');
            
            markerReverse.appendChild(pathReverse);
            defs.appendChild(markerReverse);
            
            svg.appendChild(defs);
            
            // Draw connections
            connections.forEach((conn, index) => {
                const fromNode = document.getElementById(conn.from);
                const toNode = document.getElementById(conn.to);
                
                if (fromNode && toNode) {
                    const x1 = parseInt(fromNode.style.left) + fromNode.offsetWidth / 2;
                    const y1 = parseInt(fromNode.style.top) + fromNode.offsetHeight / 2;
                    const x2 = parseInt(toNode.style.left) + toNode.offsetWidth / 2;
                    const y2 = parseInt(toNode.style.top) + toNode.offsetHeight / 2;
                    
                    // Calculate angle between centers
                    const angle = Math.atan2(y2 - y1, x2 - x1);
                    
                    // Get node shapes for better edge calculation
                    const fromShape = nodes.find(n => n.id === conn.from)?.type || 'rectangle';
                    const toShape = nodes.find(n => n.id === conn.to)?.type || 'rectangle';
                    
                    // Calculate edge points based on shape type
                    function getEdgePoint(nodeEl, centerX, centerY, angle, isFrom) {
                        const shape = isFrom ? fromShape : toShape;
                        const width = nodeEl.offsetWidth;
                        const height = nodeEl.offsetHeight;
                        
                        // For diamond shape, we need to adjust for rotation
                        if (shape === 'diamond') {
                            // Diamond is rotated 45 degrees, need to un-rotate the angle
                            const unrotatedAngle = angle - Math.PI / 4;
                            const cos = Math.cos(unrotatedAngle);
                            const sin = Math.sin(unrotatedAngle);
                            
                            // Diamond is a square rotated 45 degrees
                            const halfDiag = Math.min(width, height) / Math.sqrt(2) / 2;
                            
                            // Calculate intersection with diamond edges
                            const abscos = Math.abs(cos);
                            const abssin = Math.abs(sin);
                            
                            let scale;
                            if (abscos + abssin === 0) scale = 0;
                            else scale = halfDiag / (abscos + abssin);
                            
                            const edgeX = cos * scale;
                            const edgeY = sin * scale;
                            
                            // Rotate back to screen coordinates
                            const rotatedX = (edgeX - edgeY) * Math.sqrt(2) / 2;
                            const rotatedY = (edgeX + edgeY) * Math.sqrt(2) / 2;
                            
                            return {
                                x: centerX + rotatedX,
                                y: centerY + rotatedY
                            };
                        }
                        
                        // For circular shapes
                        if (shape === 'round') {
                            const radius = Math.min(width, height) / 2;
                            return {
                                x: centerX + Math.cos(angle) * radius,
                                y: centerY + Math.sin(angle) * radius
                            };
                        }
                        
                        // For cylinder shape (elliptical due to border-radius)
                        if (shape === 'cylinder') {
                            const radiusX = width / 2;
                            const radiusY = height / 2;
                            
                            // Ellipse edge calculation
                            const cos = Math.cos(angle);
                            const sin = Math.sin(angle);
                            const factor = 1 / Math.sqrt((cos * cos) / (radiusX * radiusX) + (sin * sin) / (radiusY * radiusY));
                            
                            return {
                                x: centerX + cos * factor,
                                y: centerY + sin * factor
                            };
                        }
                        
                        // For hexagon shape
                        if (shape === 'hexagon') {
                            const halfWidth = width / 2;
                            const halfHeight = height / 2;
                            
                            // Normalize angle to [0, 2π]
                            let a = angle % (2 * Math.PI);
                            if (a < 0) a += 2 * Math.PI;
                            
                            // Calculate intersection with hexagon edge
                            const cos = Math.cos(angle);
                            const sin = Math.sin(angle);
                            
                            // Hexagon vertices (assuming flat-top orientation)
                            const vertices = [];
                            for (let i = 0; i < 6; i++) {
                                const vertexAngle = i * Math.PI / 3;
                                vertices.push({
                                    x: halfWidth * 0.7 * Math.cos(vertexAngle),
                                    y: halfHeight * Math.sin(vertexAngle)
                                });
                            }
                            
                            // Find intersection with the appropriate edge
                            let minT = Infinity;
                            let intersectionX = 0, intersectionY = 0;
                            
                            for (let i = 0; i < 6; i++) {
                                const v1 = vertices[i];
                                const v2 = vertices[(i + 1) % 6];
                                
                                // Ray-line segment intersection
                                const dx = v2.x - v1.x;
                                const dy = v2.y - v1.y;
                                const det = dx * sin - dy * cos;
                                
                                if (Math.abs(det) > 0.001) {
                                    const t = ((v1.x * sin - v1.y * cos) / det);
                                    const u = ((v1.x * sin - v1.y * cos + cos * dy - sin * dx) / det);
                                    
                                    if (t > 0 && u >= 0 && u <= 1 && t < minT) {
                                        minT = t;
                                        intersectionX = cos * t;
                                        intersectionY = sin * t;
                                    }
                                }
                            }
                            
                            return {
                                x: centerX + intersectionX,
                                y: centerY + intersectionY
                            };
                        }
                        
                        // For rectangular and other shapes
                        const halfWidth = width / 2;
                        const halfHeight = height / 2;
                        
                        // Calculate intersection with rectangle edges
                        const cos = Math.cos(angle);
                        const sin = Math.sin(angle);
                        const abscos = Math.abs(cos);
                        const abssin = Math.abs(sin);
                        
                        let edgeX, edgeY;
                        
                        if (abscos * halfHeight > abssin * halfWidth) {
                            // Intersects left or right edge
                            edgeX = cos > 0 ? halfWidth : -halfWidth;
                            edgeY = edgeX * sin / cos;
                        } else {
                            // Intersects top or bottom edge
                            edgeY = sin > 0 ? halfHeight : -halfHeight;
                            edgeX = edgeY * cos / sin;
                        }
                        
                        // Apply shape-specific adjustments
                        if (shape === 'parallelogram') {
                            // Account for skew transformation
                            const skewAngle = -20 * Math.PI / 180;
                            const unskewedX = edgeX - edgeY * Math.tan(skewAngle);
                            
                            if (Math.abs(unskewedX) > halfWidth * 0.9) {
                                edgeX = (unskewedX > 0 ? 1 : -1) * halfWidth * 0.9;
                                edgeY = (edgeX - unskewedX) / Math.tan(skewAngle);
                            }
                        } else if (shape === 'trapezoid' || shape === 'trapezoid-alt') {
                            // Trapezoids have slanted sides
                            const slope = shape === 'trapezoid' ? 0.2 : -0.2;
                            const topWidth = halfWidth * (shape === 'trapezoid' ? 0.8 : 1);
                            const bottomWidth = halfWidth * (shape === 'trapezoid' ? 1 : 0.8);
                            
                            if (Math.abs(edgeY) >= halfHeight * 0.95) {
                                // Top or bottom edge
                                const currentWidth = edgeY > 0 ? bottomWidth : topWidth;
                                if (Math.abs(edgeX) > currentWidth) {
                                    edgeX = (edgeX > 0 ? 1 : -1) * currentWidth;
                                }
                            }
                        }
                        
                        return {
                            x: centerX + edgeX,
                            y: centerY + edgeY
                        };
                    }
                    
                    // Calculate adjusted start and end points
                    const startPoint = getEdgePoint(fromNode, x1, y1, angle, true);
                    const endPoint = getEdgePoint(toNode, x2, y2, angle + Math.PI, false);

                    // Adjust for arrow markers
                    let adjustedStartPoint = {...startPoint};
                    let adjustedEndPoint = {...endPoint};

                    // For double arrows, adjust both ends
                    if (conn.style === 'double') {
                        const arrowOffset = 5; // Offset for arrow visibility
                        const dx = endPoint.x - startPoint.x;
                        const dy = endPoint.y - startPoint.y;
                        const length = Math.sqrt(dx * dx + dy * dy);
                        const unitX = dx / length;
                        const unitY = dy / length;
                        
                        adjustedStartPoint.x = startPoint.x + unitX * arrowOffset;
                        adjustedStartPoint.y = startPoint.y + unitY * arrowOffset;
                        adjustedEndPoint.x = endPoint.x - unitX * arrowOffset;
                        adjustedEndPoint.y = endPoint.y - unitY * arrowOffset;
                    }  

                    // Create group for connection
                    const group = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                    group.setAttribute('class', 'connection-group');
                    group.setAttribute('data-connection-id', conn.id);
                    
                    const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                    line.setAttribute('x1', adjustedStartPoint.x);
                    line.setAttribute('y1', adjustedStartPoint.y);
                    line.setAttribute('x2', adjustedEndPoint.x);
                    line.setAttribute('y2', adjustedEndPoint.y);
                    line.setAttribute('class', 'connection-line' + (conn.lineStyle === 'dotted' ? ' dotted' : ''));
                    
                    // Set arrow markers based on style
                    if (conn.style === 'arrow') {
                        line.setAttribute('marker-end', 'url(#arrowhead)');
                    } else if (conn.style === 'double') {
                        line.setAttribute('marker-end', 'url(#arrowhead)');
                        line.setAttribute('marker-start', 'url(#arrowhead-reverse)');
                    }
                    
                    // Add click handler
                    line.addEventListener('click', () => selectConnection(conn.id));
                    
                    group.appendChild(line);
                    
                    // Add label if exists
                    if (conn.label) {
                        const midX = (startPoint.x + endPoint.x) / 2;
                        const midY = (startPoint.y + endPoint.y) / 2;
                        
                        // Create background rect for label
                        const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                        rect.setAttribute('class', 'connection-label-bg');
                        rect.setAttribute('x', midX - 30);
                        rect.setAttribute('y', midY - 12);
                        rect.setAttribute('width', '60');
                        rect.setAttribute('height', '24');
                        group.appendChild(rect);
                        
                        const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                        text.setAttribute('class', 'connection-label');
                        text.setAttribute('x', midX);
                        text.setAttribute('y', midY + 4);
                        text.textContent = conn.label;
                        group.appendChild(text);
                        
                        // Adjust rect width based on text
                        setTimeout(() => {
                            const bbox = text.getBBox();
                            rect.setAttribute('x', bbox.x - 4);
                            rect.setAttribute('y', bbox.y - 2);
                            rect.setAttribute('width', bbox.width + 8);
                            rect.setAttribute('height', bbox.height + 4);
                        }, 0);
                    }
                    
                    svg.appendChild(group);
                    
                    // Create delete button
                    const deleteBtn = document.createElement('div');
                    deleteBtn.className = 'connection-delete-btn';
                    deleteBtn.innerHTML = '×';
                    deleteBtn.style.left = ((startPoint.x + endPoint.x) / 2 - 10) + 'px';
                    deleteBtn.style.top = ((startPoint.y + endPoint.y) / 2 - 10) + 'px';
                    
                    deleteBtn.addEventListener('click', function(e) {
                        e.stopPropagation();
                        connections.splice(index, 1);
                        if (selectedConnection && selectedConnection.id === conn.id) {
                            selectedConnection = null;
                            document.getElementById('connectionProperties').style.display = 'none';
                            document.getElementById('selectedInfo').textContent = 'None';
                        }
                        updateConnections();
                        updateMermaidCode();
                    });
                    
                    canvas.appendChild(deleteBtn);
                    
                    // Show delete button on hover
                    group.addEventListener('mouseenter', () => {
                        deleteBtn.style.display = 'flex';
                    });
                    
                    group.addEventListener('mouseleave', () => {
                        deleteBtn.style.display = 'none';
                    });
                    
                    deleteBtn.addEventListener('mouseenter', () => {
                        deleteBtn.style.display = 'flex';
                    });
                }
            });
        }, 16);

        // Mouse Events
        document.addEventListener('mousemove', throttle(function(e) {
            if (isDragging && draggedNode) {
                const canvas = document.getElementById('canvas');
                const canvasRect = canvas.getBoundingClientRect();
                
                // Calculate scroll position
                const scrollLeft = canvas.parentElement.scrollLeft;
                const scrollTop = canvas.parentElement.scrollTop;
                
                const x = e.clientX - canvasRect.left + scrollLeft - offset.x;
                const y = e.clientY - canvasRect.top + scrollTop - offset.y;
                
                draggedNode.style.left = Math.max(0, x) + 'px';
                draggedNode.style.top = Math.max(0, y) + 'px';
                
                updateConnections();
                updateMermaidCode();
            }
            
            if (isConnecting) {
                updateTempConnection(e);
            }
        }, 16));

        document.addEventListener('mouseup', function(e) {
            if (isDragging) {
                isDragging = false;
                draggedNode = null;
            }
            
            if (isConnecting) {
                endConnection(e);
            }
        });

        // Canvas click to deselect
        document.getElementById('canvas').addEventListener('click', function(e) {
            if (e.target.id === 'canvas') {
                if (selectedNode) {
                    selectedNode.classList.remove('selected');
                    selectedNode = null;
                    document.getElementById('selectedInfo').textContent = 'None';
                    document.getElementById('nodeProperties').style.display = 'none';
                }
                if (selectedConnection) {
                    selectedConnection = null;
                    document.getElementById('connectionProperties').style.display = 'none';
                }
            }
        });

        // Update node text
        function updateNodeText() {
            if (!selectedNode) return;
            
            const text = document.getElementById('nodeText').value;
            const nodeData = nodes.find(n => n.id === selectedNode.id);
            nodeData.text = text;
            
            selectedNode.querySelector('.node-text').textContent = text;
            
            updateMermaidCode();
        }

        // Set node color
        function setNodeColor(color) {
            if (!selectedNode) return;
            
            // Validate color format
            if (!/^#[0-9A-F]{6}$/i.test(color)) {
                return;
            }
            
            const nodeData = nodes.find(n => n.id === selectedNode.id);
            
            // Check if node has wrapper
            if (selectedNode.classList.contains('node-wrapper')) {
                // For wrapped nodes, find and color the inner node
                const innerNode = selectedNode.querySelector('.node');
                if (innerNode) {
                    innerNode.style.background = color;
                }
            } else {
                // For regular nodes, set color directly
                selectedNode.style.background = color;
            }
            
            nodeData.color = color;
            
            // Update color picker and input
            document.getElementById('colorPicker').value = color;
            document.getElementById('colorInput').value = color;
            
            // Update selected color indicator
            document.querySelectorAll('.color-option').forEach(opt => {
                opt.classList.remove('selected');
                if (opt.style.background === color || 
                    rgbToHex(opt.style.background) === color.toLowerCase()) {
                    opt.classList.add('selected');
                }
            });
            
            updateMermaidCode();
        }
        
        // Handle color input
        function handleColorInput(event) {
            const input = event.target;
            let value = input.value.trim();
            
            // Auto-add # if missing
            if (value && !value.startsWith('#')) {
                value = '#' + value;
            }
            
            // Check if valid hex color
            if (/^#[0-9A-F]{6}$/i.test(value)) {
                setNodeColor(value);
            } else if (event.key === 'Enter' && /^#[0-9A-F]{3}$/i.test(value)) {
                // Convert 3-digit hex to 6-digit
                const r = value[1] + value[1];
                const g = value[2] + value[2];
                const b = value[3] + value[3];
                setNodeColor('#' + r + g + b);
            }
        }
        
        // Convert RGB to Hex
        function rgbToHex(rgb) {
            if (!rgb || !rgb.startsWith('rgb')) return rgb;
            
            const values = rgb.match(/\d+/g);
            if (!values || values.length < 3) return rgb;
            
            const r = parseInt(values[0]).toString(16).padStart(2, '0');
            const g = parseInt(values[1]).toString(16).padStart(2, '0');
            const b = parseInt(values[2]).toString(16).padStart(2, '0');
            
            return '#' + r + g + b;
        }

        // Update Mermaid code
        function updateMermaidCode() {
            let code = `graph ${flowDirection}\n`;
            
            // Check which nodes are inside subgraphs
            const nodeSubgraphMap = {};
            const canvasEl = document.getElementById('canvas');
            
            subgraphs.forEach(subgraph => {
                const subgraphEl = document.getElementById(subgraph.id);
                if (!subgraphEl) return;
                
                nodes.forEach(node => {
                    const nodeEl = document.getElementById(node.id);
                    if (!nodeEl) return;
                    
                    // Get positions relative to canvas
                    const nodeLeft = parseInt(nodeEl.style.left);
                    const nodeTop = parseInt(nodeEl.style.top);
                    const nodeRight = nodeLeft + nodeEl.offsetWidth;
                    const nodeBottom = nodeTop + nodeEl.offsetHeight;
                    
                    const subLeft = parseInt(subgraphEl.style.left);
                    const subTop = parseInt(subgraphEl.style.top);
                    const subRight = subLeft + parseInt(subgraphEl.style.width);
                    const subBottom = subTop + parseInt(subgraphEl.style.height);
                    
                    // Check if node center is inside subgraph
                    const nodeCenterX = nodeLeft + nodeEl.offsetWidth / 2;
                    const nodeCenterY = nodeTop + nodeEl.offsetHeight / 2;
                    
                    if (nodeCenterX >= subLeft && nodeCenterX <= subRight &&
                        nodeCenterY >= subTop && nodeCenterY <= subBottom) {
                        nodeSubgraphMap[node.id] = subgraph.id;
                    }
                });
            });
            
            // Generate subgraphs
            subgraphs.forEach(subgraph => {
                const nodesInSubgraph = nodes.filter(node => nodeSubgraphMap[node.id] === subgraph.id);
                if (nodesInSubgraph.length > 0) {
                    code += `    subgraph ${subgraph.id}["${subgraph.title}"]\n`;
                    
                    // Add nodes that belong to this subgraph
                    nodesInSubgraph.forEach(node => {
                        const text = node.text.replace(/"/g, '&quot;');
                        let nodeCode = `        ${node.id}`;
                        
                        switch(node.type) {
                            case 'rectangle':
                                nodeCode += `["${text}"]`;
                                break;
                            case 'round':
                                nodeCode += `(("${text}"))`;
                                break;
                            case 'stadium':
                                nodeCode += `(["${text}"])`;
                                break;
                            case 'subroutine':
                                nodeCode += `[["${text}"]]`;
                                break;
                            case 'diamond':
                                nodeCode += `{"${text}"}`;
                                break;
                            case 'hexagon':
                                nodeCode += `{{"${text}"}}`;
                                break;
                            case 'parallelogram':
                                nodeCode += `[/"${text}"/]`;
                                break;
                            case 'trapezoid':
                                nodeCode += `[/"${text}"\\]`;
                                break;
                            case 'trapezoid-alt':
                                nodeCode += `[\\"${text}"/]`;
                                break;
                            case 'cylinder':
                                nodeCode += `[("${text}")]`;
                                break;
                        }
                        
                        code += nodeCode + '\n';
                    });
                    
                    code += '    end\n';
                }
            });
            
            // Add nodes that are not in any subgraph
            nodes.forEach(node => {
                if (!nodeSubgraphMap[node.id]) {
                    const text = node.text.replace(/"/g, '&quot;');
                    let nodeCode = `    ${node.id}`;
                    
                    switch(node.type) {
                        case 'rectangle':
                            nodeCode += `["${text}"]`;
                            break;
                        case 'round':
                            nodeCode += `(("${text}"))`;
                            break;
                        case 'stadium':
                            nodeCode += `(["${text}"])`;
                            break;
                        case 'subroutine':
                            nodeCode += `[["${text}"]]`;
                            break;
                        case 'diamond':
                            nodeCode += `{"${text}"}`;
                            break;
                        case 'hexagon':
                            nodeCode += `{{"${text}"}}`;
                            break;
                        case 'parallelogram':
                            nodeCode += `[/"${text}"/]`;
                            break;
                        case 'trapezoid':
                            nodeCode += `[/"${text}"\\]`;
                            break;
                        case 'trapezoid-alt':
                            nodeCode += `[\\"${text}"/]`;
                            break;
                        case 'cylinder':
                            nodeCode += `[("${text}")]`;
                            break;
                    }
                    
                    code += nodeCode + '\n';
                }
            });
            
            // Add styles
            nodes.forEach(node => {
                if (node.color && node.color !== '#007acc') {
                    code += `    style ${node.id} fill:${node.color}\n`;
                }
            });
            
            // Add connections
            connections.forEach(conn => {
                let connectionCode = `    ${conn.from} `;
                
                // Connection style
                if (conn.style === 'double') {
                    connectionCode += '<-->';
                } else if (conn.style === 'none') {
                    connectionCode += '---';
                } else {
                    connectionCode += '-->';
                }
                
                // Add label if exists
                if (conn.label) {
                    if (conn.style === 'none') {
                        connectionCode = `    ${conn.from} ---|${conn.label}|`;
                    } else {
                        connectionCode = `    ${conn.from} -->|${conn.label}|`;
                    }
                }
                
                // Add line style
                if (conn.lineStyle === 'dotted') {
                    if (conn.style === 'double') {
                        connectionCode = connectionCode.replace('<-->', '<-.->');
                    } else if (conn.style === 'none') {
                        connectionCode = connectionCode.replace('---', '-.-');
                    } else { // single arrow
                        connectionCode = connectionCode.replace('-->', '-.->');
                    }
                }
                
                connectionCode += ` ${conn.to}\n`;
                code += connectionCode;
            });
            
            document.getElementById('mermaidCode').textContent = code;
            renderMermaidPreview(code);
        }

        // Render preview with throttling
        const renderMermaidPreview = throttle(async function(code) {
            const preview = document.getElementById('mermaidPreview');
            
            if (nodes.length === 0 && subgraphs.length === 0) {
                preview.innerHTML = '<div style="color: var(--text-tertiary); text-align: center;">Add nodes to see preview</div>';
                return;
            }
            
            // Clear previous content but keep a placeholder
            const placeholder = preview.innerHTML;
            
            const mermaidDiv = document.createElement('div');
            mermaidDiv.className = 'mermaid';
            mermaidDiv.textContent = code; // Use textContent instead of innerHTML
            mermaidDiv.style.opacity = '0';
            preview.innerHTML = '';
            preview.appendChild(mermaidDiv);
            
            try {
                // Remove any existing diagrams
                await mermaid.init(undefined, mermaidDiv);
                
                // Wait for render to complete
                setTimeout(() => {
                    const svg = preview.querySelector('svg');
                    if (svg) {
                        // Get all visual elements
                        const allGroups = svg.querySelectorAll('g');
                        let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
                        
                        // Calculate actual bounds of all content
                        allGroups.forEach(g => {
                            try {
                                const bbox = g.getBBox();
                                if (bbox.width > 0 && bbox.height > 0) {
                                    minX = Math.min(minX, bbox.x);
                                    minY = Math.min(minY, bbox.y);
                                    maxX = Math.max(maxX, bbox.x + bbox.width);
                                    maxY = Math.max(maxY, bbox.y + bbox.height);
                                }
                            } catch (e) {
                                // Skip elements that can't provide bbox
                            }
                        });
                        
                        // If we couldn't get bounds, use SVG viewBox or defaults
                        if (!isFinite(minX)) {
                            const viewBox = svg.getAttribute('viewBox');
                            if (viewBox) {
                                [minX, minY, maxX, maxY] = viewBox.split(' ').map(Number);
                                maxX = minX + maxX; // viewBox provides width, not maxX
                                maxY = minY + maxY; // viewBox provides height, not maxY
                            } else {
                                minX = 0; minY = 0; maxX = 200; maxY = 200;
                            }
                        }
                        
                        // Calculate content dimensions
                        const contentWidth = maxX - minX;
                        const contentHeight = maxY - minY;
                        
                        // Calculate center point
                        const centerX = minX + contentWidth / 2;
                        const centerY = minY + contentHeight / 2;
                        
                        // Add padding proportional to content size
                        const padding = Math.max(20, Math.min(contentWidth, contentHeight) * 0.2);
                        
                        // Get preview container dimensions
                        const previewContainer = preview.parentElement;
                        const containerWidth = previewContainer.clientWidth;
                        const containerHeight = previewContainer.clientHeight;
                        
                        // Calculate scale to fit content in container
                        const scaleX = (containerWidth - padding * 2) / contentWidth;
                        const scaleY = (containerHeight - padding * 2) / contentHeight;
                        const scale = Math.min(scaleX, scaleY, 1); // Don't scale up beyond 1
                        
                        // Calculate viewBox to center content
                        const viewWidth = containerWidth / scale;
                        const viewHeight = containerHeight / scale;
                        const viewX = centerX - viewWidth / 2;
                        const viewY = centerY - viewHeight / 2;
                        
                        svg.setAttribute('viewBox', `${viewX} ${viewY} ${viewWidth} ${viewHeight}`);
                        
                        // Set up proper sizing
                        svg.setAttribute('width', '100%');
                        svg.setAttribute('height', '100%');
                        svg.setAttribute('preserveAspectRatio', 'xMidYMid meet');
                        svg.style.maxWidth = '100%';
                        svg.style.maxHeight = '100%';
                        
                        // Disable all pointer events on SVG elements to prevent hover effects
                        svg.style.pointerEvents = 'none';
                        const allElements = svg.querySelectorAll('*');
                        allElements.forEach(el => {
                            el.style.pointerEvents = 'none';
                            el.style.cursor = 'default';
                        });
                        
                        // Fade in
                        mermaidDiv.style.transition = 'opacity 0.2s';
                        mermaidDiv.style.opacity = '1';
                    }
                }, 100);
            } catch (error) {
                console.error('Mermaid render error:', error);
                preview.innerHTML = '<div style="color: #f5222d;">Error rendering diagram</div>';
            }
        }, 300); // Throttle to 300ms

        // Toolbar functions
        function showDirectionModal() {
            document.getElementById('directionModal').style.display = 'block';
            document.getElementById('modalBackdrop').style.display = 'block';
        }

        function closeModal() {
            document.getElementById('directionModal').style.display = 'none';
            document.getElementById('modalBackdrop').style.display = 'none';
        }

        function setDirection(direction) {
            flowDirection = direction;
            closeModal();
            updateMermaidCode();
        }

        function toggleSubgraphMode() {
            alert('Use the "Add Group" button in the shape panel to create groups. Then drag nodes into the group box.');
        }

        function clearCanvas() {
            if (!confirm('Clear all nodes and connections?')) return;
            
            const canvas = document.getElementById('canvas');
            canvas.innerHTML = '<svg id="connectionSvg"></svg>';
            nodes = [];
            connections = [];
            subgraphs = [];
            nodeIdCounter = 0;
            subgraphIdCounter = 0;
            connectionIdCounter = 0;
            selectedNode = null;
            selectedSubgraph = null;
            selectedConnection = null;
            document.getElementById('selectedInfo').textContent = 'None';
            document.getElementById('nodeProperties').style.display = 'none';
            document.getElementById('connectionProperties').style.display = 'none';
            updateConnections();
            updateMermaidCode();
        }

        function toggleCodeView() {
            const container = document.getElementById('codeContainer');
            const icon = document.getElementById('toggleIcon');
            
            container.classList.toggle('collapsed');
            icon.textContent = container.classList.contains('collapsed') ? '▲' : '▼';
        }

        function copyCode() {
            const code = document.getElementById('mermaidCode').textContent;
            navigator.clipboard.writeText(code).then(() => {
                alert('Mermaid code copied to clipboard!');
            });
        }

        function exportSVG() {
            const svgElement = document.querySelector('#mermaidPreview svg');
            if (!svgElement) {
                alert('No diagram to export');
                return;
            }
            
            const svgData = new XMLSerializer().serializeToString(svgElement);
            const blob = new Blob([svgData], { type: 'image/svg+xml' });
            const url = URL.createObjectURL(blob);
            
            const a = document.createElement('a');
            a.href = url;
            a.download = 'mermaid-diagram.svg';
            a.click();
            
            URL.revokeObjectURL(url);
        }

        // Canvas Events for Subgraph Creation
        let subgraphStartPos = null;
        let tempSubgraph = null;
        
        document.getElementById('canvas').addEventListener('mousedown', function(e) {
            if (subgraphMode && e.target.id === 'canvas') {
                subgraphStartPos = { x: e.offsetX, y: e.offsetY };
                
                tempSubgraph = document.createElement('div');
                tempSubgraph.className = 'subgraph creating-subgraph';
                tempSubgraph.style.left = subgraphStartPos.x + 'px';
                tempSubgraph.style.top = subgraphStartPos.y + 'px';
                tempSubgraph.style.width = '0px';
                tempSubgraph.style.height = '0px';
                
                document.getElementById('canvas').appendChild(tempSubgraph);
            }
        });
        
        document.getElementById('canvas').addEventListener('mousemove', function(e) {
            if (subgraphMode && subgraphStartPos && tempSubgraph) {
                const currentX = e.offsetX;
                const currentY = e.offsetY;
                
                const width = Math.abs(currentX - subgraphStartPos.x);
                const height = Math.abs(currentY - subgraphStartPos.y);
                const left = Math.min(currentX, subgraphStartPos.x);
                const top = Math.min(currentY, subgraphStartPos.y);
                
                tempSubgraph.style.left = left + 'px';
                tempSubgraph.style.top = top + 'px';
                tempSubgraph.style.width = width + 'px';
                tempSubgraph.style.height = height + 'px';
            }
        });
        
        document.getElementById('canvas').addEventListener('mouseup', function(e) {
            if (subgraphMode && subgraphStartPos && tempSubgraph) {
                const width = parseInt(tempSubgraph.style.width);
                const height = parseInt(tempSubgraph.style.height);
                
                if (width > 50 && height > 50) {
                    createSubgraph(
                        parseInt(tempSubgraph.style.left),
                        parseInt(tempSubgraph.style.top),
                        width,
                        height
                    );
                }
                
                tempSubgraph.remove();
                tempSubgraph = null;
                subgraphStartPos = null;
            }
        });
        
        function createQuickSubgraph() {
            const canvas = document.getElementById('canvas');
            const container = document.querySelector('.canvas-container');
            
            // Position at center of viewport
            const scrollLeft = container.scrollLeft;
            const scrollTop = container.scrollTop;
            const viewWidth = container.clientWidth;
            const viewHeight = container.clientHeight;
            
            const x = scrollLeft + viewWidth / 2 - 150;
            const y = scrollTop + viewHeight / 2 - 100;
            
            createSubgraph(x, y, 300, 200);
        }
        
        function createSubgraph(x, y, width, height, title) {
            const subgraphId = `subgraph${subgraphIdCounter++}`;
            
            if (!title) {
                title = `Group ${subgraphIdCounter}`;
            }
            
            const subgraph = document.createElement('div');
            subgraph.className = 'subgraph';
            subgraph.id = subgraphId;
            subgraph.style.left = x + 'px';
            subgraph.style.top = y + 'px';
            subgraph.style.width = width + 'px';
            subgraph.style.height = height + 'px';
            subgraph.style.zIndex = 1; // Below nodes
            
            const titleEl = document.createElement('input');
            titleEl.className = 'subgraph-title';
            titleEl.value = title;
            titleEl.readOnly = true;
            
            // Double click to edit
            titleEl.addEventListener('dblclick', (e) => {
                e.stopPropagation();
                startEditingSubgraphTitle(titleEl, subgraphId);
            });
            
            subgraph.appendChild(titleEl);
            
            const deleteBtn = document.createElement('div');
            deleteBtn.className = 'subgraph-delete';
            deleteBtn.innerHTML = '×';
            deleteBtn.onclick = function(e) {
                e.stopPropagation();
                if (confirm(`Delete group "${titleEl.value}"?`)) {
                    subgraph.remove();
                    subgraphs = subgraphs.filter(s => s.id !== subgraphId);
                    if (selectedSubgraph && selectedSubgraph.id === subgraphId) {
                        selectedSubgraph = null;
                        document.getElementById('selectedInfo').textContent = 'None';
                    }
                    updateMermaidCode();
                }
            };
            subgraph.appendChild(deleteBtn);
            
            const resizeHandle = document.createElement('div');
            resizeHandle.className = 'subgraph-resize';
            subgraph.appendChild(resizeHandle);
            
            subgraph.addEventListener('mousedown', handleSubgraphMouseDown);
            
            // Add resize functionality
            resizeHandle.addEventListener('mousedown', function(e) {
                e.stopPropagation();
                const startX = e.clientX;
                const startY = e.clientY;
                const startWidth = parseInt(subgraph.style.width);
                const startHeight = parseInt(subgraph.style.height);
                
                function resize(e) {
                    const newWidth = startWidth + e.clientX - startX;
                    const newHeight = startHeight + e.clientY - startY;
                    subgraph.style.width = Math.max(150, newWidth) + 'px';
                    subgraph.style.height = Math.max(100, newHeight) + 'px';
                    updateMermaidCode();
                }
                
                function stopResize() {
                    document.removeEventListener('mousemove', resize);
                    document.removeEventListener('mouseup', stopResize);
                }
                
                document.addEventListener('mousemove', resize);
                document.addEventListener('mouseup', stopResize);
            });
            
            document.getElementById('canvas').appendChild(subgraph);
            
            subgraphs.push({
                id: subgraphId,
                title: title,
                x: x,
                y: y,
                width: width,
                height: height
            });
            
            updateMermaidCode();
        }
        
        function startEditingSubgraphTitle(titleEl, subgraphId) {
            titleEl.readOnly = false;
            titleEl.classList.add('editing');
            titleEl.focus();
            titleEl.select();
            
            const finishEditing = () => {
                titleEl.readOnly = true;
                titleEl.classList.remove('editing');
                const subgraphData = subgraphs.find(s => s.id === subgraphId);
                subgraphData.title = titleEl.value;
                updateMermaidCode();
            };
            
            titleEl.addEventListener('blur', finishEditing, { once: true });
            titleEl.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    titleEl.blur();
                }
            });
        }
        
        function handleSubgraphMouseDown(e) {
            if (e.target.classList.contains('subgraph-resize') ||
                e.target.classList.contains('editing')) {
                return;
            }
            
            if (subgraphMode) return;
            
            const subgraph = e.currentTarget;
            selectSubgraph(subgraph);
            
            // Start dragging
            isDragging = true;
            draggedNode = subgraph;
            const rect = subgraph.getBoundingClientRect();
            offset.x = e.clientX - rect.left;
            offset.y = e.clientY - rect.top;
        }
        
        function selectSubgraph(subgraph) {
            if (selectedSubgraph) {
                selectedSubgraph.classList.remove('selected');
            }
            if (selectedNode) {
                selectedNode.classList.remove('selected');
            }
            
            selectedSubgraph = subgraph;
            subgraph.classList.add('selected');
            
            const subgraphData = subgraphs.find(s => s.id === subgraph.id);
            document.getElementById('selectedInfo').textContent = `Subgraph: ${subgraphData.title}`;
            document.getElementById('nodeProperties').style.display = 'none';
            document.getElementById('connectionProperties').style.display = 'none';
        }
        
        // Initialize Resize Functionality
        const resizeHandle = document.getElementById('resizeHandle');
        const canvasContainer = document.getElementById('canvasContainer');
        const previewArea = document.querySelector('.preview-area');
        const editorArea = document.querySelector('.editor-area');
        
        let isResizing = false;
        let startX = 0;
        let startCanvasWidth = 0;
        let startPreviewWidth = 0;
        
        resizeHandle.addEventListener('mousedown', function(e) {
            isResizing = true;
            startX = e.clientX;
            const canvasRect = canvasContainer.getBoundingClientRect();
            const previewRect = previewArea.getBoundingClientRect();
            startCanvasWidth = canvasRect.width;
            startPreviewWidth = previewRect.width;
            
            // Add temporary overlay to prevent iframe interference
            const overlay = document.createElement('div');
            overlay.id = 'resize-overlay';
            overlay.style.position = 'fixed';
            overlay.style.top = '0';
            overlay.style.left = '0';
            overlay.style.right = '0';
            overlay.style.bottom = '0';
            overlay.style.zIndex = '9999';
            overlay.style.cursor = 'ew-resize';
            document.body.appendChild(overlay);
        });
        
        document.addEventListener('mousemove', function(e) {
            if (!isResizing) return;
            
            const deltaX = e.clientX - startX;
            const workspaceWidth = document.querySelector('.workspace').offsetWidth;
            const propertiesPanelWidth = document.querySelector('.properties-panel').offsetWidth;
            const editorAreaWidth = workspaceWidth - propertiesPanelWidth;
            
            // Calculate new widths
            let newCanvasWidth = startCanvasWidth + deltaX;
            let newPreviewWidth = startPreviewWidth - deltaX;
            
            // Apply constraints
            const resizeHandleWidth = 16;
            const availableWidth = editorAreaWidth - resizeHandleWidth;
            
            // Set minimum preview width to 30% of available space (7:3 ratio limit)
            // Since preview has border-box sizing, this includes padding
            const minPreviewWidth = Math.max(366, Math.ceil(availableWidth * 0.3)); // 350px content + 16px right padding
            const minCanvasWidth = 300;
            
            // Ensure preview doesn't get too small (maintain 7:3 ratio limit)
            if (newPreviewWidth < minPreviewWidth) {
                newPreviewWidth = minPreviewWidth;
                newCanvasWidth = availableWidth - newPreviewWidth;
            }
            
            // Ensure canvas doesn't get too small
            if (newCanvasWidth < minCanvasWidth) {
                newCanvasWidth = minCanvasWidth;
                newPreviewWidth = availableWidth - newCanvasWidth;
            }
            
            // Ensure total equals available space
            const totalWidth = newCanvasWidth + newPreviewWidth;
            if (Math.abs(totalWidth - availableWidth) > 1) {
                const ratio = availableWidth / totalWidth;
                newCanvasWidth *= ratio;
                newPreviewWidth *= ratio;
            }
            
            // Apply new widths using flex
            // For canvas, use the calculated width directly
            canvasContainer.style.flex = `0 0 ${newCanvasWidth}px`;
            
            // For preview area with border-box, just set the flex width which includes padding
            previewArea.style.flex = `0 0 ${newPreviewWidth}px`;
            previewArea.style.width = 'auto'; // Let flex handle the width
            
            // Update connections after resize
            updateConnections();
        });
        
        document.addEventListener('mouseup', function() {
            if (isResizing) {
                isResizing = false;
                // Remove overlay
                const overlay = document.getElementById('resize-overlay');
                if (overlay) overlay.remove();
            }
        });
        
        // Initialize
        function initializeEditor() {
            updateMermaidCode();
            
            // Set default shape selection
            const defaultShape = document.querySelector('.shape-item[data-shape="rectangle"]');
            if (defaultShape) {
                defaultShape.classList.add('selected');
                selectedShapeType = 'rectangle';
            }
        }
        
        // Initialize when page loads
        initializeEditor();
    </script>
</body>
</html>
</body>
</html>
